# template for privileged mode / run as Root / host network / host PID /host IPC / hostpath / ReadOnlyFileSystem / AllowPrivilegeEscalation
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spodsecuritychecks
  annotations:
    argocd.argoproj.io/sync-wave: "1"
spec:
  crd:
    spec:
      names:
        kind: K8sPodSecurityChecks
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spodsecuritychecks
        
        all_containers[container] {
            some c
            container := input.review.object.spec.containers[c]
        }
        all_containers[container] {
            input.review.object.spec.initContainers
            some c
            container := input.review.object.spec.initContainers[c]
        }
        all_containers[container] {
            input.review.object.spec.ephemeralContainers
            some c
            container := input.review.object.spec.ephemeralContainers[c]
        }
        default msg = ""

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          container := all_containers[_]
          container.securityContext.privileged == true
          m := sprintf("the container %q is run in privileged mode (privileged=true)", [container.name])
        }

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          container := all_containers[_]
          not container.securityContext.runAsNonRoot == true
          m := sprintf("the container %q is run as Root (runAsNonRoot=false)", [container.name])
        }

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          input.review.object.spec.hostNetwork == true
          m := sprintf("the pod %q uses the host network (hostNetwork=true)", [input.review.object.metadata.name])
        }

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          input.review.object.spec.hostPID == true
          m := sprintf("the pod %q uses the host PID (hostPID=true)", [input.review.object.metadata.name])
        }

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          input.review.object.spec.hostIPC == true
          m := sprintf("the pod %q uses the host IPC (hostIPC=true)", [input.review.object.metadata.name])          
        }

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          some v
          volume := input.review.object.spec.volumes[v]
          volume.hostPath
          volume.hostPath.path != ""
          not startswith(volume.hostPath.path, "/var/log/containers")
          m := sprintf("The volume hostPath '%s' is not authorized", [volume.hostPath.path])
        }

        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          some v
          volume := input.review.object.spec.volumes[v]
          volume.hostPath.path
          not startswith(volume.hostPath.path, "/var/log/containers")
          m := sprintf("The volume hostPath '%s' is not authorized in Pod %q.", [volume.hostPath.path, input.review.object.metadata.name])
        }
        
        violation[{"msg": m}] {
          input.review.kind.kind == "Pod"
          container := all_containers[_]
          not input.review.object.metadata.annotations["gatekeeper.sh/exempt-rofs"] == "true"
          not container.securityContext.readOnlyRootFilesystem == true
          m := sprintf("The container %q must define readOnlyRootFilesystem=true", [input.review.object.spec.containers[c].name])
        }

        violation[{"msg": m}]{
          input.review.kind.kind == "Pod"
          container := all_containers[_]
          container.securityContext.allowPrivilegeEscalation == true
          m := sprintf("The container %q uses privilege escalation (allowPrivilegeEscalation=true)", [container.name])
        }
